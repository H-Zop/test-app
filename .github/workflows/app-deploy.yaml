name: Build and Deploy for Go service - OCI
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
env:
  SERVICE_NAME: servb
  NAMESPACE: test-app
  CLUSTER_NAME: stage-clus
  ARTIFACT_REPO_NAME: zop-dev
jobs:
  dockerize:
    runs-on: ubuntu-latest
    name: 🐳 Dockerize
    outputs:
      image: ${{ steps.output-image.outputs.image }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v4
        with:
          go-version: '1.21'
      - name: Get dependencies
        run: |
          go mod download
      - name: Build
        run: |
          CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -buildvcs=false -o main
      - name: Configure OCI CLI
        run: |
          mkdir -p ~/.oci
          
          # Extract values from JSON credentials
          FINGERPRINT=$(echo '${{ secrets.OCI_SERVICE_CREDENTIALS }}' | jq -r '.serviceCredentials.fingerprint')
          PRIVATE_KEY=$(echo '${{ secrets.OCI_SERVICE_CREDENTIALS }}' | jq -r '.serviceCredentials.private_key')
          REGION=$(echo '${{ secrets.OCI_SERVICE_CREDENTIALS }}' | jq -r '.serviceCredentials.region')
          TENANCY_OCID=$(echo '${{ secrets.OCI_SERVICE_CREDENTIALS }}' | jq -r '.serviceCredentials.tenancy_ocid')
          USER_OCID=$(echo '${{ secrets.OCI_SERVICE_CREDENTIALS }}' | jq -r '.serviceCredentials.user_ocid')
          
          # Create private key file
          echo "$PRIVATE_KEY" > ~/.oci/private_key.pem
          chmod 600 ~/.oci/private_key.pem
          
          # Create OCI config file
          cat > ~/.oci/config << EOF
          [DEFAULT]
          user=$USER_OCID
          fingerprint=$FINGERPRINT
          tenancy=$TENANCY_OCID
          region=$REGION
          key_file=~/.oci/private_key.pem
          EOF
      - name: Install OCI CLI
        run: |
          curl -L https://raw.githubusercontent.com/oracle/oci-cli/master/scripts/install/install.sh | bash
          echo "$HOME/bin" >> $GITHUB_PATH
      - name: Login to OCI Artifact Registry
        run: |
          # Extract region from credentials for dynamic registry URL
          REGION=$(echo '${{ secrets.OCI_SERVICE_CREDENTIALS }}' | jq -r '.serviceCredentials.region')
          echo "${{ secrets.OCI_AUTH_TOKEN }}" | docker login ${REGION}.ocir.io -u '${{ secrets.OCI_USERNAME }}' --password-stdin
      - name: Build and Push Docker Image to OCI Artifact Registry
        run: |
          # Extract region from credentials for dynamic image URL
          REGION=$(echo '${{ secrets.OCI_SERVICE_CREDENTIALS }}' | jq -r '.serviceCredentials.region')
          IMAGE_URL="${REGION}.ocir.io/${{ env.ARTIFACT_REPO_NAME }}/${{ env.SERVICE_NAME }}:${{ github.sha }}"
          
          docker build -t ${IMAGE_URL} .
          docker push ${IMAGE_URL}
          
          # Also tag as latest
          docker tag ${IMAGE_URL} "${REGION}.ocir.io/${{ env.ARTIFACT_REPO_NAME }}/${{ env.SERVICE_NAME }}:latest"
          docker push "${REGION}.ocir.io/${{ env.ARTIFACT_REPO_NAME }}/${{ env.SERVICE_NAME }}:latest"
      - id: output-image
        run: |
          REGION=$(echo '${{ secrets.OCI_SERVICE_CREDENTIALS }}' | jq -r '.serviceCredentials.region')
          echo "image=${REGION}.ocir.io/${{ env.ARTIFACT_REPO_NAME }}/${{ env.SERVICE_NAME }}:${{ github.sha }}" >> "$GITHUB_OUTPUT"
  deployment:
    runs-on: ubuntu-latest
    needs: dockerize
    name: 🚀 Deploy
    env:
      image: ${{ needs.dockerize.outputs.image }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      - name: Configure OCI CLI
        run: |
          mkdir -p ~/.oci
          
          # Extract values from JSON credentials
          FINGERPRINT=$(echo '${{ secrets.OCI_SERVICE_CREDENTIALS }}' | jq -r '.serviceCredentials.fingerprint')
          PRIVATE_KEY=$(echo '${{ secrets.OCI_SERVICE_CREDENTIALS }}' | jq -r '.serviceCredentials.private_key')
          REGION=$(echo '${{ secrets.OCI_SERVICE_CREDENTIALS }}' | jq -r '.serviceCredentials.region')
          TENANCY_OCID=$(echo '${{ secrets.OCI_SERVICE_CREDENTIALS }}' | jq -r '.serviceCredentials.tenancy_ocid')
          USER_OCID=$(echo '${{ secrets.OCI_SERVICE_CREDENTIALS }}' | jq -r '.serviceCredentials.user_ocid')
          
          # Create private key file
          echo "$PRIVATE_KEY" > ~/.oci/private_key.pem
          chmod 600 ~/.oci/private_key.pem
          
          # Create OCI config file
          cat > ~/.oci/config << EOF
          [DEFAULT]
          user=$USER_OCID
          fingerprint=$FINGERPRINT
          tenancy=$TENANCY_OCID
          region=$REGION
          key_file=~/.oci/private_key.pem
          EOF
      - name: Install OCI CLI
        run: |
          curl -L https://raw.githubusercontent.com/oracle/oci-cli/master/scripts/install/install.sh | bash
          echo "$HOME/bin" >> $GITHUB_PATH
      - name: Install and Configure kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
      - name: Get OKE Cluster Kubeconfig
        run: |
          # Extract region from credentials
          REGION=$(echo '${{ secrets.OCI_SERVICE_CREDENTIALS }}' | jq -r '.serviceCredentials.region')
          
          oci ce cluster create-kubeconfig \
            --cluster-id ${{ secrets.OKE_CLUSTER_ID }} \
            --file ~/.kube/config \
            --region ${REGION} \
            --token-version 2.0.0 \
            --kube-endpoint PUBLIC_ENDPOINT
      - name: Update Deployment Image
        run: |
          kubectl set image deployment/${{ env.SERVICE_NAME }} ${{ env.SERVICE_NAME }}=${{ env.image }} --namespace ${{ env.NAMESPACE }}
      - name: Verify Deployment
        run: |
          kubectl rollout status deployment/${{ env.SERVICE_NAME }} --namespace ${{ env.NAMESPACE }} --timeout=300s